<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>ClusterPies</title>
	<!--<link rel="stylesheet" href="http://cdn.leafletjs.com/leaflet-1.0.3/leaflet.css" />-->
	<link rel="stylesheet" href="https://unpkg.com/leaflet@1.0.3/dist/leaflet.css"
		  integrity="sha512-07I2e+7D8p6he1SIM+1twR5TIrhUQn9+I6yjqD53JQjFiMf8EtC93ty0/5vJTZGF8aAocvHYNEDJajGdNx1IsQ=="
		  crossorigin=""/>
	<!--<link href='https://api.mapbox.com/mapbox.js/plugins/leaflet-markercluster/v0.4.0/MarkerCluster.css' rel='stylesheet' />-->
	<link rel='stylesheet' href='/static/css/MarkerCluster.css'/>
	<link rel="stylesheet" href="/static/css/clusterpies.css"/>

	<script src="https://unpkg.com/leaflet@1.0.3/dist/leaflet.js"
			integrity="sha512-A7vV8IFfih/D732iSSKi20u/ooOfj/AGehOKq0f4vLT1Zr2Y+RX7C+w8A1gaSasGtRUZpF/NZgzSAu4/Gc41Lg=="
			crossorigin=""></script>
	<!--<script src="http://cdn.leafletjs.com/leaflet-1.0.3/leaflet.js" charset="utf-8"></script>-->
	<!--<script src='https://api.mapbox.com/mapbox.js/plugins/leaflet-markercluster/v0.4.0/leaflet.markercluster.js'></script>-->
	<script src='/static/js/leaflet.markercluster-src.js'></script>
	<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
</head>
<body>
<div id="container" style="width: 100%; height: 600px;">
	<div id="map"/>
</div>
<script>
	"use strict"
	var geojson,
		metadata,
		geojsonPath = 'traffic.geojson',
		categoryField = '5074', //This is the fieldname for marker category (used in the pie and legend)
		iconField = '5065', //This is the fieldame for marker icon
		popupFields = ['5065','5055','5074'], //Popup will display these fields
		tileServer = 'http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
		tileAttribution = 'Map data: <a href="http://openstreetmap.org">OSM</a>',
		rmax = 30, //Maximum radius for cluster pies
		markerclusters = L.markerClusterGroup({
			maxClusterRadius: 2*rmax,
			iconCreateFunction: function defineClusterIcon(cluster) {
				var children = cluster.getAllChildMarkers(),
					n = children.length, //Get number of markers in cluster
					strokeWidth = 1, //Set clusterpie stroke width
					r = rmax-2*strokeWidth-(n<10?12:n<100?8:n<1000?4:0), //Calculate clusterpie radius...
					iconDim = (r+strokeWidth)*2, //...and divIcon dimensions (leaflet really want to know the size)
					data = d3.nest() //Build a dataset for the pie chart
						.key(function(d) { return d.feature.properties[categoryField]; })
						.entries(children, d3.map)
					//Create a new divIcon and assign the svg markup to the html property
					, myIcon = new L.DivIcon({
						html: bakeThePie({ //bake some svg markup
							data: data,
							valueFunc: function(d){return d.values.length;},
							strokeWidth: 1,
							outerRadius: r,
							innerRadius: r-10,
							pieClass: 'cluster-pie',
							pieLabel: n,
							pieLabelClass: 'marker-cluster-pie-label',
							pathClassFunc: function(d){return "category-"+d.data.key;},
							pathTitleFunc: function(d){return metadata.fields[categoryField].lookup[d.data.key]+' ('+d.data.values.length+' accident'+(d.data.values.length!=1?'s':'')+')';}
						})
						, className: 'marker-cluster'
						, iconSize: new L.Point(iconDim, iconDim)
					});
				return myIcon;
			}
		}),
	    map = L.map('map').setView([59.95, 10.78], 8)
	;

	//Add basemap
	L.tileLayer(tileServer, {attribution: tileAttribution,  maxZoom: 15}).addTo(map);
	//and the empty markercluster layer
	map.addLayer(markerclusters);

	//Ready to go, load the geojson
	d3.json(geojsonPath, function(error, data) {
    	if (!error) {
			geojson = data;
			metadata = data.properties;
			var markers = L.geoJson(geojson, {
				pointToLayer: function defineFeature(feature, latlng) {
					var categoryVal = feature.properties[categoryField],
						iconVal = feature.properties[iconField];
					var myClass = 'marker category-'+categoryVal+' icon-'+iconVal;
					var myIcon = L.divIcon({ className: myClass, iconSize:null });
					return L.marker(latlng, {icon: myIcon});
				}
				, onEachFeature: function defineFeaturePopup(feature, layer) {
					var props = feature.properties,
						fields = metadata.fields,
						popupContent = '';
					popupFields.map( function(key) {
						if (props[key]) {
							var val = props[key],
							label = fields[key].name;
							if (fields[key].lookup) {
								val = fields[key].lookup[val];
							}
							popupContent += '<span class="attribute"><span class="label">'+label+':</span> '+val+'</span>';
						}
					});
					popupContent = '<div class="map-popup">'+popupContent+'</div>';
					layer.bindPopup(popupContent,{offset: L.point(1,-2)});
				}
			});
			markerclusters.addLayer(markers);
			map.fitBounds(markers.getBounds());
			map.attributionControl.addAttribution(metadata.attribution);
			renderLegend();
      } else {
		  console.log('Could not load data...');
      }
	});

/*function that generates a svg markup for the pie chart*/
function bakeThePie(options) {
    /*data and valueFunc are required*/
    if (!options.data || !options.valueFunc) {
        return '';
    }
    var data= options.data,
        valueFunc = options.valueFunc,
        r = options.outerRadius?options.outerRadius:28, //Default outer radius = 28px
        rInner = options.innerRadius?options.innerRadius:r-10, //Default inner radius = r-10
        strokeWidth = options.strokeWidth?options.strokeWidth:1, //Default stroke is 1
        pathClassFunc = options.pathClassFunc?options.pathClassFunc:function(){return '';}, //Class for each path
        pathTitleFunc = options.pathTitleFunc?options.pathTitleFunc:function(){return '';}, //Title for each path
        pieClass = options.pieClass?options.pieClass:'marker-cluster-pie', //Class for the whole pie
        pieLabel = options.pieLabel?options.pieLabel:d3.sum(data,valueFunc), //Label for the whole pie
        pieLabelClass = options.pieLabelClass?options.pieLabelClass:'marker-cluster-pie-label',//Class for the pie label

        origo = (r+strokeWidth), //Center coordinate
        w = origo*2, //width and height of the svg element
        h = w,
        donut = d3.layout.pie(),
        arc = d3.svg.arc().innerRadius(rInner).outerRadius(r)
	;

    //Create an svg element
    var svg = document.createElementNS(d3.ns.prefix.svg, 'svg');
    //Create the pie chart
    var vis = d3.select(svg)
        .data([data])
        .attr('class', pieClass)
        .attr('width', w)
        .attr('height', h)
	;

    var arcs = vis.selectAll('g.arc')
        .data(donut.value(valueFunc))
        .enter().append('svg:g')
        .attr('class', 'arc')
        .attr('transform', 'translate(' + origo + ',' + origo + ')')
	;

    arcs.append('svg:path')
        .attr('class', pathClassFunc)
        .attr('stroke-width', strokeWidth)
        .attr('d', arc)
        .append('svg:title')
	  	.text(pathTitleFunc)
	;

    vis.append('text')
        .attr('x',origo)
        .attr('y',origo)
        .attr('class', pieLabelClass)
        .attr('text-anchor', 'middle')
        //.attr('dominant-baseline', 'central')
        .attr('dy','.3em')        /*IE doesn't seem to support dominant-baseline, but setting dy to .3em does the trick*/
        .text(pieLabel)
	;
    //Return the svg-markup rather than the actual element
    return serializeXmlNode(svg);
}

/*Function for generating a legend with the same categories as in the clusterPie*/
function renderLegend() {
    var data = d3.entries(metadata.fields[categoryField].lookup),
		legenddiv = d3.select('body').append('div')
        .attr('id','legend')
	;

    var heading = legenddiv.append('div')
        .classed('legendheading', true)
        .text(metadata.fields[categoryField].name)
	;

    var legenditems = legenddiv.selectAll('.legenditem')
        .data(data)
	;

    legenditems
        .enter()
        .append('div')
        .attr('class',function(d){return 'category-'+d.key;})
        .classed({'legenditem': true})
        .text(function(d){return d.value;})
	;
}

/*Helper function*/
function serializeXmlNode(xmlNode) {
    if (typeof window.XMLSerializer != "undefined") {
        return (new window.XMLSerializer()).serializeToString(xmlNode);
    } else if (typeof xmlNode.xml != "undefined") {
        return xmlNode.xml;
    }
    return "";
}
</script>
</body>
</html>